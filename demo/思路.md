# 思路

使用了 hooks

可以把绑定数据的流程放在 数组，在 hooks 运行时加入列队

任何变量都用函数包裹，通过闭包保存状态

穿过组件的闭包使用 getter 绑定，给子组件传值

```js
// in index.5.js
function Children1( ) {
    return (
        dom.div({ class:() => this.data.a + 1  },
            () => this.children
        )
    )
}

let Children = Components(Children1)


let i = 1
function index() {
    return (
        dom.div({},
            Children({
                a: () => i
            },
                'A'
            )
        )
    )
}

let Index = Components(index)

Index()

{
    type: 'div',
    attr: {},
    children: [
        {
            type: 'div',
            attr: {
                class: 2
            },
            children: ['A']
        }
    ]
}

i= 2

Index()

{
    type: 'div',
    attr: {},
    children: [
        {
            type: 'div',
            attr: {
                class: 3
            },
            children: ['A']
        }
    ]
}

const $ = Data(0)
            .loaded(()=>{})
            .watch({})
            .computer(()=>{})
            .die(()=>{});

$.data === 0

$.data = 1
$.data = 19

// -> $.data === 19
```

一个组件的执行顺序

```js
Index()

index
    useData // 创建hooks
    useData
    Children
        useData
        Children2
        useData
    Children
        useData
```

每个 `Components` 函数有四个周期：

```js
Components(com) {
    // 0.初始化组件，可以保存该组件组装专有的公共属性
    return ( attr, ...children ) => {
        // 1.开始执行执行组件，但没有开始渲染和装配组件内部 vnode
        // 可以在这里出发 上一个组件收集 hooks，并更新 hooks 的操作
        ... do something
        // 2.开始执行 vnode
        let vnode = com()
        // 3.执行完成
        return vnode
    } 
}
  
```